// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Belt_SetInt from "rescript/lib/es6/belt_SetInt.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var InvalidLetter = /* @__PURE__ */Caml_exceptions.create("Run.InvalidLetter");

var NoEmptySeat = /* @__PURE__ */Caml_exceptions.create("Run.NoEmptySeat");

var InvalidInstruction = /* @__PURE__ */Caml_exceptions.create("Run.InvalidInstruction");

var InvalidStatement = /* @__PURE__ */Caml_exceptions.create("Run.InvalidStatement");

var InvalidStatementIndex = /* @__PURE__ */Caml_exceptions.create("Run.InvalidStatementIndex");

function parseStatement(raw) {
  var result = /(acc|jmp|nop) ([-+])([0-9]+)$/.exec(raw);
  if (result !== null) {
    var captures = Belt_Array.map(result, (function (x) {
            return Belt_Option.getWithDefault((x == null) ? undefined : Caml_option.some(x), "");
          }));
    var n = Belt_Option.getExn(Belt_Int.fromString(Belt_Option.getExn(Belt_Array.get(captures, 3))));
    var match = Belt_Option.getExn(Belt_Array.get(captures, 2));
    var n$1 = match === "+" ? n : -n | 0;
    var instruction = Belt_Option.getExn(Belt_Array.get(captures, 1));
    return {
            instruction: instruction,
            n: n$1
          };
  }
  throw {
        RE_EXN_ID: InvalidStatement,
        _1: raw,
        Error: new Error()
      };
}

var statements = Belt_Array.map(Fs.readFileSync("input.txt", "utf-8").split("\n"), parseStatement);

function tick(_state, statements) {
  while(true) {
    var state = _state;
    if (Belt_SetInt.has(state.seen, state.pos)) {
      return state;
    }
    var match = Belt_Array.get(statements, state.pos);
    if (match === undefined) {
      return state;
    }
    var instruction = match.instruction;
    switch (instruction) {
      case "acc" :
          _state = {
            pos: state.pos + 1 | 0,
            acc: state.acc + match.n | 0,
            seen: Belt_SetInt.add(state.seen, state.pos)
          };
          continue ;
      case "jmp" :
          _state = {
            pos: state.pos + match.n | 0,
            acc: state.acc,
            seen: Belt_SetInt.add(state.seen, state.pos)
          };
          continue ;
      case "nop" :
          _state = {
            pos: state.pos + 1 | 0,
            acc: state.acc,
            seen: Belt_SetInt.add(state.seen, state.pos)
          };
          continue ;
      default:
        throw {
              RE_EXN_ID: InvalidInstruction,
              _1: instruction,
              Error: new Error()
            };
    }
  };
}

console.log("Part A:");

console.log(tick({
          pos: 0,
          acc: 0,
          seen: undefined
        }, statements).acc);

var index = statements.findIndex(function (statement, i) {
      if (statement.instruction !== "jmp") {
        return false;
      }
      var set = Belt_Array.set(statements, i, {
            instruction: "nop",
            n: 0
          });
      if (!set) {
        return false;
      }
      var state = tick({
            pos: 0,
            acc: 0,
            seen: undefined
          }, statements);
      var terminated = state.pos >= statements.length;
      Belt_Array.set(statements, i, statement);
      return terminated;
    });

if (Belt_Array.set(statements, index, {
        instruction: "nop",
        n: 0
      })) {
  console.log("Part B:");
  console.log(tick({
            pos: 0,
            acc: 0,
            seen: undefined
          }, statements).acc);
}

export {
  InvalidLetter ,
  NoEmptySeat ,
  InvalidInstruction ,
  InvalidStatement ,
  InvalidStatementIndex ,
  parseStatement ,
  statements ,
  tick ,
  index ,
  
}
/* statements Not a pure module */
